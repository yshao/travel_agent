

import json
import re
import os
import google.generativeai as genai
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# --- State Management ---
STATE_FILE = "conversation_state.json"

def get_default_state():
    return {
        "current_phase": "INITIAL",
        "plan": {
            "destination": None,
            "duration": None,
            "month": None,
            "traveler_type": None,
            "interests": [],
            "budget": None,
        },
    }

def save_state(state):
    with open(STATE_FILE, "w") as f:
        json.dump(state, f)

# Initialize state
if os.path.exists(STATE_FILE) and os.path.getsize(STATE_FILE) > 0:
    with open(STATE_FILE, "r") as f:
        try:
            state = json.load(f)
        except json.JSONDecodeError:
            state = get_default_state()
else:
    state = get_default_state()

# --- Gemini API Configuration ---
# TODO: Add your Gemini API key here
# For example:
# genai.configure(api_key="YOUR_API_KEY")
gemini_api_key = os.getenv("GEMINI_API_KEY")
if gemini_api_key:
    genai.configure(api_key=gemini_api_key)
else:
    print("Gemini API key not found. Please set the GEMINI_API_KEY environment variable.")

def call_gemini(prompt):
    """
    Calls the Gemini API to generate content based on the prompt.
    """
    try:
        model = genai.GenerativeModel('gemini-pro')
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        return f"Error calling Gemini API: {e}"


import datetime

def validate_date(date_str):
    try:
        datetime.datetime.strptime(date_str, '%B %d, %Y')
        return True
    except ValueError:
        return False

def validate_itinerary_dates(itinerary_text, start_month, duration):
    # This is a simplified validation. A more robust one would parse all dates and check sequence.
    # For now, we'll just check if the start month is present in the itinerary.
    return start_month.lower() in itinerary_text.lower()

def validate_location_format(location_text):
    return bool(location_text and len(location_text) > 5) # Simple check for non-empty and reasonable length

def validate_description_format(description_text):
    return bool(description_text and len(description_text) > 10) # Simple check for non-empty and reasonable length

def parse_initial_request(user_input):
    """Parses the user's initial travel request to extract key details."""
    plan = state["plan"]

    # Only parse these if they are not already set
    if not plan["destination"]:
        destination_match = re.search(r"trip to ([\w\s]+)", user_input, re.IGNORECASE)
        if destination_match:
            plan["destination"] = destination_match.group(1).strip()

    if not plan["duration"]:
        duration_match = re.search(r"(\d+)-day", user_input, re.IGNORECASE)
        if duration_match:
            plan["duration"] = int(duration_match.group(1))

    if not plan["traveler_type"]:
        traveler_type_match = re.search(r"for a ([\w\s]+)", user_input, re.IGNORECASE)
        if traveler_type_match:
            plan["traveler_type"] = traveler_type_match.group(1).strip()

    if not plan["interests"]:
        interests_match = re.search(r"interested in ([\w\s,]+)", user_input, re.IGNORECASE)
        if interests_match:
            plan["interests"] = [i.strip() for i in interests_match.group(1).split(",") if i.strip()]

    # Always try to parse month and budget, as they can be provided in follow-up questions
    month_match = re.search(r"\b(january|february|march|april|may|june|july|august|september|october|november|december)\b", user_input, re.IGNORECASE)
    if month_match:
        plan["month"] = month_match.group(1).strip()

    budget_match = re.search(r"budget around \$(\d+)", user_input, re.IGNORECASE)
    if budget_match:
        plan["budget"] = int(budget_match.group(1))


def check_missing_info():
    """Checks for missing information in the travel plan."""
    missing = []
    if not state["plan"]["destination"]:
        missing.append("destination")
    if not state["plan"]["duration"]:
        missing.append("duration")
    if not state["plan"]["month"]:
        missing.append("month")
    if not state["plan"]["traveler_type"]:
        missing.append("traveler type")
    if not state["plan"]["interests"]:
        missing.append("interests")
    if not state["plan"]["budget"]:
        missing.append("budget")
    return missing




    # Always parse the user input to update the plan
    parse_initial_request(user_input)
    missing_info = check_missing_info()

    if not missing_info and state["current_phase"] == "INITIAL":
        state["current_phase"] = "CONFIRMED"
        ai_response = "**Understood Parameters:**\n"
        for key, value in state["plan"].items():
            if value:
                ai_response += f"- {key.replace('_', ' ').title()}: {value}\n"
        ai_response += "\nParameters confirmed! I'm ready to generate a high-level itinerary. Type 'generate itinerary' to proceed."
    elif state["current_phase"] == "INITIAL":
        ai_response = "**Understood Parameters:**\n"
        for key, value in state["plan"].items():
            if value:
                ai_response += f"- {key.replace('_', ' ').title()}: {value}\n"
        
        # Ask clarifying questions
        if "month" in missing_info:
            ai_response += "\nWhat month are you planning to travel in?"
        if "budget" in missing_info:
             ai_response += "\nWhat is your approximate budget for this trip?"

    elif state["current_phase"] == "CONFIRMED":
        if user_input.lower() == "generate itinerary":
            state["current_phase"] = "ITINERARY"
            # Construct a more detailed prompt for Gemini to generate the itinerary
            prompt = f"Generate a {state['plan']['duration']}-day itinerary for a trip to {state['plan']['destination']} in {state['plan']['month']} for {state['plan']['traveler_type']} interested in {', '.join(state['plan']['interests'])}. The budget is around ${state['plan']['budget']}. For each day, include a specific date (e.g., Day 1: July 16, 2025). Focus on the following format as described in PROMPT.md: ## X-Day [Destination] Itinerary ([Interests] Focus)\n\n**Day 1: [Date]: ...**\n* ...\n\n**Day 2: [Date]: ...**\n* ...\n\nType 'details [Day X]' or 'details [attraction name]' for more information, or 'budget estimate' to see a cost breakdown."
            ai_response = call_gemini(prompt)
        else:
            ai_response = "Please type 'generate itinerary' to proceed."

    elif state["current_phase"] == "ITINERARY":
        if user_input.lower().startswith("details"):
            # Construct a more detailed prompt for Gemini to provide details
            detail_query = user_input.replace("details ", "").strip()
            prompt = f"Provide practical details for '{detail_query}' from the itinerary for a trip to {state['plan']['destination']}. Include estimated time, brief description (text only), exact address/real-world location (if applicable), estimated cost (if applicable), suggestions for nearby attractions or food, and relevant Google Search queries or direct browsing links for booking. Focus on the format as described in PROMPT.md."
            gemini_response = call_gemini(prompt)
            ai_response = gemini_response

            # Validate the extracted information
            date_match = re.search(r"Day \d+: ([A-Za-z]+ \d+, \d{4})", gemini_response)
            location_match = re.search(r"Location: (.+)", gemini_response)
            description_match = re.search(r"Description: (.+)", gemini_response)

            if date_match and not validate_date(date_match.group(1)):
                ai_response += "\n\nValidation Warning: The date format in the itinerary details is incorrect."
            if location_match and not validate_location_format(location_match.group(1)):
                ai_response += "\n\nValidation Warning: The location format in the itinerary details is incorrect or too short."
            if description_match and not validate_description_format(description_match.group(1)):
                ai_response += "\n\nValidation Warning: The description in the itinerary details is too short."

        elif user_input.lower() == "budget estimate":
            state["current_phase"] = "BUDGET"
            # Construct a more detailed prompt for Gemini to provide budget estimate
            prompt = f"Provide a rough budget breakdown and optimization tips for a {state['plan']['duration']}-day trip to {state['plan']['destination']} with a budget of ${state['plan']['budget']}. Break down costs for flights, accommodation, food and activities. Suggest ways to optimize the budget. Focus on the format as described in PROMPT.md."
            ai_response = call_gemini(prompt)
        else:
            ai_response = "Type 'details [Day X]' or 'budget estimate'."
    
    elif state["current_phase"] == "BUDGET":
        if user_input.lower() == "new plan":
            state = get_default_state()
            ai_response = "Ready for a new travel plan."
        else:
            ai_response = "What else can I help you with, or would you like to start a 'new plan'?'"
    
    print(ai_response)
    log_conversation(user_input, ai_response)
    save_state(state)

def main(verbose=False):
    """Main function to run the travel assistant CLI."""
    global state
    log_file = "conversation_history.log"

    def log_conversation(user, ai):
        with open(log_file, "a") as f:
            f.write(f"User: {user}\n")
            f.write(f"AI: {ai}\n")
            f.write("---\n")

    if verbose:
        print("Verbose mode enabled")

    print("Welcome to the AI Travel Planning Assistant!")
    print("You can start by describing your travel plans, e.g., 'Plan a 7-day trip to Rome in Spring for a couple interested in history and food.'")

    # Simulated user inputs
    simulated_inputs = [
        "Plan a 7-day trip to Rome in May for a couple interested in history and food.",
        "generate itinerary",
        "details Day 1",
        "details Colosseum",
        "budget estimate",
        "new plan",
        "quit"
    ]

    for user_input in simulated_inputs:
        print(f"> {user_input}")
        process_user_input(user_input, log_conversation)

    print("Simulated interaction complete.")











if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="AI Travel Planning Assistant")
    parser.add_argument("initial_input", nargs="?", help="Initial travel plan description")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose logging")
    args = parser.parse_args()

    main(verbose=args.verbose)

